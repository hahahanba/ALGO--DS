# Leetcode 题解 - 二叉搜索树
<!-- GFM-TOC -->
* [Leetcode 题解 - 二叉搜索树](#leetcode-题解---二叉搜索树)
    * [二叉搜索树](#二叉搜索树)
        * [1. 将有序数组转换为二叉搜索树](#1-将有序数组转换为二叉搜索树)
        * [2. 有序链表转换二叉搜索树](#2-有序链表转换二叉搜索树)
        * [3. 恢复二叉搜索树](#3-恢复二叉搜索树)
        * [4. 验证二叉搜索树](#4-验证二叉搜索树)
        * [5. 二叉搜索树中的搜索](#5-二叉搜索树中的搜索)
        * [6. 二叉搜索树中第K小的元素](#6-二叉搜索树中第K小的元素)
        * [7. 二叉搜索树中的众数](#7-二叉搜索树中的众数)
        * [8. 删除二叉搜索树中的节点](#8-删除二叉搜索树中的节点)
        * [9. 二叉搜索树中的插入操作](#9-二叉搜索树中的插入操作)
        * [10. 修剪二叉搜索树](#10-修剪二叉搜索树)
<!-- GFM-TOC -->


## 二叉搜索树

一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用递归来处理。

### 1. 将有序数组转换为二叉搜索树

108\. Convert Sorted Array to Binary Search Tree (Easy)

[Leetcode](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/) / [力扣](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

```python
# 递归1
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def helper(left, right):
            if left > right:
                return
            # 找中点
            mid = (left + right + randint(0, 1)) // 2
            root = TreeNode(nums[mid])
            root.left = helper(left, mid-1)
            root.right = helper(mid + 1, right)
            return root

        return helper(0, len(nums) - 1)  
```

### 2. 有序链表转换二叉搜索树

109\. Convert Sorted List to Binary Search Tree (Medium)

[Leetcode](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/) / [力扣](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)

```python
# 递归1
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        # 快慢指针找中点
        def findmid(head, tail):
            fast, slow = head, head
            while fast != tail and fast.next!= tail :
                slow = slow.next
                fast = fast.next.next
            return slow
        
        def helper(head, tail):
            if head == tail: 
                return 
            mid = findmid(head, tail)
            root = TreeNode(mid.val)
            root.left = helper(head, mid)
            root.right = helper(mid.next, tail)
            return root
            
        return helper(head, None)
```

### 3. 恢复二叉搜索树

99\. Maximum Depth of Binary Tree (Easy)

[Leetcode]() / [力扣]()

```python
# 递归1

```

### 4. 验证二叉搜索树

98\. Maximum Depth of Binary Tree (Easy)

[Leetcode]() / [力扣]()

```python
# 递归1

```

### 5. 二叉搜索树中的搜索

104\. Maximum Depth of Binary Tree (Easy)

[Leetcode]() / [力扣]()

```python
# 递归1

```

### 6. 二叉搜索树中第K小的元素

104\. Maximum Depth of Binary Tree (Easy)

[Leetcode]() / [力扣]()

```python
# 递归1

```

### 7. 二叉搜索树中的众数

104\. Maximum Depth of Binary Tree (Easy)

[Leetcode]() / [力扣]()

```python
# 递归1

```

### 8. 删除二叉搜索树中的节点

104\. Maximum Depth of Binary Tree (Easy)

[Leetcode]() / [力扣]()

```python
# 递归1

```

### 9. 二叉搜索树中的插入操作

104\. Maximum Depth of Binary Tree (Easy)

[Leetcode]() / [力扣]()

```python
# 递归1

```

### 10. 修剪二叉搜索树

104\. Maximum Depth of Binary Tree (Easy)

[Leetcode]() / [力扣]()

```python
# 递归1

```
