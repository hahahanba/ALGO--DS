# Leetcode 题解 - 树
<!-- GFM-TOC -->
* [Leetcode 题解 - 树](#leetcode-题解---树)
    * [二叉树的遍历](#二叉树的遍历)
        * [1. 二叉树的前序遍历](#1-二叉树的前序遍历)
        * [2. 二叉树的后序遍历](#2-二叉树的后序遍历)
        * [3. 二叉树的中序遍历](#3-二叉树的中序遍历)
        * [4. 二叉树的层序遍历](#4-二叉树的层序遍历)
        * [5. 二叉树的层序遍历II](#5-二叉树的层序遍历II)
        * [6. 二叉树的锯齿形遍历](#6-二叉树的锯齿形遍历)
        * [7. 二叉树的垂序遍历](#7-二叉树的垂序遍历)
    * [N叉树的遍历](#N叉树的遍历)
        * [1. N叉树的前序遍历](#1-N叉树的前序遍历)
        * [2. N叉树的后序遍历](#2-N叉树的前序遍历)
        * [3. N叉树的层序遍历](#3-N叉树的层序遍历)
    * [其他](#其他)
        * [1. 层数最深叶子节点的和](#1-层数最深叶子节点的和)
<!-- GFM-TOC -->

## 二叉树的遍历

### 1. 二叉树的前序遍历

144\. Binary Tree Preorder Traversal (Medium)

[Leetcode](https://leetcode.com/problems/binary-tree-preorder-traversal/) / [力扣](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```python
## 递归
 def preorderTraversal(self, root):
     def helper(root):
         if not root:
             return
         res.append(root.val)
         helper(root.left)
         helper(root.right)
     res = []
     helper(root)
     return res
```

```python
## 迭代
 def preorderTraversal(self, root):
     res = []
     stack = []
     cur = root
     while stack or cur:
         while cur:
             res.append(cur.val)
             stack.append(cur)
             cur = cur.left
         cur = stack.pop()
         cur = cur.right
     return res
```

### 2. 二叉树的后序遍历

145\. Binary Tree Postorder Traversal (Medium)

[Leetcode](https://leetcode.com/problems/binary-tree-postorder-traversal/) / [力扣](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```python
## 递归
 def postorderTraversal(self, root):
     def helper(root):
         if not root:
             return
         helper(root.left)
         helper(root.right)
         res.append(root.val)
     res = []
     helper(root)
     return res
```

```python
## 迭代
def postorderTraversal(self, root):
  res = []
  stack = []
  cur = root
  while stack or cur:
      while cur:
          res.append(cur.val)
          stack.append(cur)
          cur = cur.right
      cur = stack.pop()
      cur = cur.left
  return res[::-1]
```

### 3. 二叉树的中序遍历

94\. Binary Tree Inorder Traversal (Medium)

[Leetcode](https://leetcode.com/problems/binary-tree-inorder-traversal/) / [力扣](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```python
## 递归
 def inorderTraversal(self, root):
     def helper(root):
         if not root:
             return
         helper(root.left)
         res.append(root.val)
         helper(root.right)
     res = []
     helper(root)
     return res
```

```python
## 迭代
 def inorderTraversal(self, root):
     res = []
     stack = []
     cur = root
     while stack or cur:
         while cur:
             stack.append(cur)
             cur = cur.left
         cur = stack.pop()
         res.append(cur.val)
         cur = cur.right
     return res
```

### 4. 二叉树的层序遍历

102\. Binary Tree Level Order Traversal (Medium)

[Leetcode](https://leetcode.com/problems/binary-tree-level-order-traversal/) / [力扣](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```python
## 递归
 def levelOrder(self, root):
     def helper(root, level):
         if not root:
             return
         # 当遍历到一个新的深度 level，而最终结果 res 中还没有创建 level 对应的列表时，
         # 应该在 res 中新建一个列表用来保存该 level 的所有节点。
         if len(res) == level:
             res.append([])
         res[level].append(root.val)
         helper(root.left, level + 1)
         helper(root.right, level + 1)
     res = []
     helper(root, 0)
     return res
```

```python
## 迭代
 def levelOrder(self, root):
     if not root:
         return []
     cur_level, res = [root], []
     while cur_level:
         next_level, tmp_res = [], []
         for node in cur_level:
             tmp_res.append(node.val)
             if node.left:
                 next_level.append(node.left)
             if node.right:
                 next_level.append(node.right)
         res.append(tmp_res)
         cur_level = next_level
     return res
```
