# Leetcode 题解 - 树的路径
<!-- GFM-TOC -->
* [Leetcode 题解 - 树的路径](#leetcode-题解---树的路径)
    * [树的路径](#树的路径)
        * [1. 路径和I](#1-路径和I)
        * [2. 路径和II](#2-路径和II)
        * [3. 路径和III](#3-路径和III)
        * [4. 求根到叶子节点数字之和](#4-求根到叶子节点数字之和)
        * [5. 二叉树的所有路径](#5-二叉树的所有路径)
        * [6. 二叉树中最大路径和](#6-二叉树中最大路径和)
        * [7. 二叉树直径](#7-二叉树直径)
        * [8. 最长同值路径](#8-最长同值路径)
<!-- GFM-TOC -->

## 树的路径

### 1. 路径和I

112\. Path Sum (Easy)

[Leetcode](https://leetcode.com/problems/path-sum/) / [力扣](https://leetcode-cn.com/problems/path-sum/)

```python
## 递归
def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
    if not root:
        return False
    if not root.left and not root.right:
        return targetSum == root.val
    # 是root.val
    return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)
```

```python
## BFS
def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
    if not root:
        return False
    queue = collections.deque()
    queue.append((root, root.val))
    while queue:
        node, path = queue.popleft()
        if not node.left and not node.right and path == targetSum:
            return True
        if node.left:
            queue.append((node.left, path + node.left.val))
        if node.right:
            queue.append((node.right, path + node.right.val))

    return False
```

### 2. 路径和II

113\. Path Sum II (Medium)

[Leetcode](https://leetcode.com/problems/path-sum-ii/) / [力扣](https://leetcode-cn.com/problems/path-sum-ii/)

```python
## 递归
def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:
    def helper(root, path, path_sum):
        if not root:
            return []
        if not root.left and not root.right:
            if path_sum - root.val == 0:
                res.append(path + [root.val])
                return
        helper(root.left, path + [root.val], path_sum - root.val)
        helper(root.right, path + [root.val], path_sum - root.val)

    res = []
    helper(root, [], targetSum)
    return res
```

```python
## 迭代
def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:
    if not root:
        return []
    queue = collections.deque()
    queue.append((root, [root.val], root.val))
    res = []
    while queue:
        node, path, path_sum = queue.popleft()
        if not node.left and not node.right:
            if path_sum == targetSum:
                res.append(path)
        if node.left:
            queue.append((node.left, path + [node.left.val], path_sum + node.left.val))
        if node.right:
            queue.append((node.right, path + [node.right.val], path_sum + node.right.val))

    return res
```

### 3. 路径和III

113\. Path Sum III (Medium)

前缀和

[Leetcode](https://leetcode.com/problems/path-sum-iii/) / [力扣](https://leetcode-cn.com/problems/path-sum-iii/)

```python
## 递归

```

```python
## 迭代

```
