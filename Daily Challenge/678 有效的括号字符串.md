# 678 有效的括号字符串

### 题目链接

[Leetcode](https://leetcode.com/problems/valid-parenthesis-string/) / [力扣](https://leetcode-cn.com/problems/valid-parenthesis-string/)

678\. Valid Parenthesis String (Medium)

给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：

* 任何左括号 ( 必须有相应的右括号 )。
* 任何右括号 ) 必须有相应的左括号 ( 。
* 左括号 ( 必须在对应的右括号之前 )。
* * 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。
一个空字符串也被视为有效字符串。


示例1:

```
输入: "()"
输出: True
```

示例2:

```
输入: "(*)"
输出: True
```

示例3:

```
输入: "(*))"
输出: True
```

### 算法

遍历两次，第一次顺序，第二次逆序。

* 第一次遇到左括号加一，右括号减一，星号加一，最后保证cnt >= 0,也就是可以保证产生的左括号足够。
* 第二次遇到右括号加一，左括号减一，星号加一，最后保证cnt >= 0,也就是可以保证产生的右括号足够。

当两次遍历都是True，那么说明有效

### 必然性

* 首先必要性是显然的，如果某个方向不能满足足够的括号，那肯定不有效。

### 充分性

* 充分性在于对于*的处理。
* 对于有效的`*`的转换方案，我们在两次遍历中分别将`*`看作'('和')'，那么其实只要两次遍历用于匹配的那些`*`是不相同的集合即可。具体一点，我们假设我们的匹配方案是尽可能的先匹配最近的()`(函数中用+-a来代表最近的()匹配，用1来表示` `*` `变换出来的括号)`

1. 对于第一次遍历，我们将`*`看作'('，那么最后'('的数量>=')'的数量。最后能够匹配到所有的)，可能会剩余一些'('或者`*`。 那么匹配到的')'有两种，一种直接和最近的'('匹配的')'，一种是和`*`匹配的')‘，我们将第一种的字符对集合记为A，第二个记为B
2. 同样，对于第二次遍历，我们将`*`看作')'，最后所有'('都会被匹配，同样划分为两种，一种是和最近的')'匹配的，一种是和`*`匹配的，第一种匹配集合记为C，第二种记为D。

这样，我们发现两次遍历后，所有的'('和')'都至少出现在A,B,C,D，中的一个集合中；简单思考，我们不难发现，A和C是相同的，因为我们的规则总会先去匹配到最近的括号。而B和D中的`*`一定是不同的`*`，这个就是我们证明的目标！因为如果B和D中某个`*`是相同位置的`*`的话，那么这个`*`在两次遍历中分别匹配了')'和'('，那么其实这个`*`一定在一对'('和')'之间，而这两个'('其实')'其实本身应该优先相互匹配，出现在集合A(也就是C)中，而不应该属于B和D中。由此推出矛盾，于是我们知道C和D中的`*`是不重合的。

这样我们就得到了一个充分的转换方案，将B中的`*`转换为'('，D中的`*`转换为')'，剩余的没在B和D中的看做空，就能够得到一个有效的括号序列。所以这个两次遍历的判断条件是充分的。


```python
def checkValidString(self, s: str) -> bool:
    def helper(a):
        count = 0
        for c in s if a == 1 else reversed(s):
            if c == '(': count += a
            if c == ')': count += -a
            if c == '*': count += 1
            if count < 0:
                return False
        return True
    return helper(1) and helper(-1)
```
